#!/usr/bin/env ruby

require_relative './cell'


# Contains sudoku game board
class Grid
  include Enumerable
  # Create Sudoku game grid of given dimension
  def initialize(dimension,data)
    @dimension = dimension
    @grid = Array.new(dimension) do
      Array.new(dimension)
    end
data.each_with_index{|e, i|
  e.each_with_index{ |y, x|
  @grid[i][x] = Cell.new(y, @dimension)}
}
@grid
  end


  def one_solution(row, col, cell, width)
    sol = ''
    cell.value.to_i == 0 ? sol += '   ' : sol += ' ' + cell.value.to_s + ' '
    sol += '|' if col % width == 0 && col != @dimension
    if col == @dimension
      sol += "\n"
      sol += "---------+---------+---------\n" if row % width == 0
    end
    sol
  end

  # Return string with game board in a console friendly format
  def to_s(width = 3)
    i = 0
    reduce("---------+---------+---------\n") do |sum, cell|
      row = (i / 9) + 1
      col = (i % 9) + 1
      i += 1
      sum + one_solution(row, col, cell, width)
    end
  end

  # First element in the sudoku grid
  def first
    @grid[0][0]
  end

  # Last element in the sudoku grid
  def last
    @grid[@dimension - 1][@dimension - 1]
  end

  # Return value at given position
  def value(x, y)
    @grid[x][y].value
  end

  def find_prev(zero, pos)
    pos = zero.index(pos) - 1
    return -1 if pos < 0
    zero[pos]
  end

  def try_value(row, col, zero, pos)
    h = value(row, col) + 1
    if h > 9
      self[row, col] = 0
      pos = find_prev(zero, pos)
    else
      self[row, col] = h
      pos += 1 if valid?
    end
    pos
  end

  def fill(z)
    pos = 0
    while pos >= 0
      row = pos / 9
      col = pos % 9
      return true if pos == 81
      self[row, col].origin == 0 ? pos = try_value(row, col, z, pos) : pos += 1
    end
  end

  def numeric
    zero = []
    i = 0
    each do |x|
      zero.push(i) unless x.filled?
      x.set_org
      i += 1
    end
    fill(zero)
  end

  # Marks number +z+ which shouldn't be at position [x, y]
  def exclude(x, y, z)
    @grid[x][y].exclude(z)
  end

  # True when there is already a number
  def filled?(x, y)
    @grid[x][y].value != 0
  end

  # True when no game was loaded
  def empty?
    each do |cell|
      return false if cell.value.to_i != 0
    end
    true
  end

  # Yields elements in given row
  def row_elems(x)
    return @grid[x] unless block_given?
    @grid[x].each do |g|
      yield g
    end
  end

  def typ_arg(arg)
    return 0 if arg < 3
    return 1 if arg < 6
    2
  end

  def block_row?(arg, i)
    typ_arg(arg) == typ_arg(i)
  end

  def block_col?(arg, col)
    arg % 3 == typ_arg(col)
  end

  def block(arg)
    res = []
    i = 0
    each do |x|
      row = (i / 9)
      col = (i % 9)
      res.push(x) if block_row?(arg, row) && block_col?(arg, col)
      i += 1
    end
    return res unless block_given?
    res.each { |g| yield g }
  end

  # Yields elements in given column
  def col_elems(y)
    col = []
    @grid.each do |sub|
      yield sub[y] if block_given?
      col.push(sub[y]) unless block_given?
    end
    col unless block_given?
  end

  def number_block(x, y)
    (3 * (x / 3)) + y / 3
  end

  # Yields elements from block which is
  # containing element at given position
  def block_elems(x, y)
    return block(number_block(x, y)) unless block_given?
    block(number_block(x, y)).each { |v| yield v }
  end

  # With one argument return row, with 2, element
  # at given position
  def [](*args)
    if args.length == 1
      @grid[args[0]]
    else
      @grid[args[0]][args[1]]
    end
  end
 
  # With one argument sets row, with 2 element
  def []=(*args)
    if args.length == 2
      @grid[args[0]] = args[1]
    else
      @grid[args[0]][args[1]] = Cell.new(args[2], @dimension)
    end
  end

  def can_delete(row,column)
    cell = Cell.new(0,@dimension)
    (0..8).each do | i | 
      if i != column && @grid[row][i].value != 0
       cell.exclude(@grid[row][i].value)
      end
      if i != row && @grid[i][column].value != 0
        cell.exclude(@grid[i][column].value)
      end
    end
    block_elems(row, column) do |n|
      if n != @grid[row][column] && n.value !=0
        cell.exclude(n.value)
      end
    end 
    cell.filled?
  end
  # Return number of missing numbers in grid
  def missing
    num = 0
    each do |cell|
      num += 1 if cell.value.to_i == 0
    end
    num
  end

  # Number of filled cells
  def filled
    num = 0
    each do |cell|
      num += 1 if cell.value.to_i != 0
    end
    num
  end

  # Number of rows in this sudoku
  def rows
    @dimension
  end

  # Number of columns in this sudoku
  def cols
    @dimension
  end

  # Iterates over all elements, left to right, top to bottom
  def each
    return to_enum(:each) unless block_given?
    @grid.each do |sub|
      sub.each do |cell|
        yield cell
       
      end
    end
  end

  def valid_enum(enum)
    pom = []
    enum.each do |e|
      return false if pom.count(e.to_i) > 0 && e.to_i != 0
      pom << e.to_i
    end
    true
  end

  # Return true if no filled number break sudoku rules
  def valid?
    (0..@dimension - 1).each do |i|
      return false unless valid_enum(row_elems(i))
      return false unless valid_enum(col_elems(i))
      return false unless valid_enum(block(i))
    end
    true
  end

  # Serialize grid values to a one line string
  def solution
    solution = ''
    each do |cell|
      solution += cell.value.to_s
    end
    solution
  end
end
